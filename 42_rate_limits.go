// [_Ограничение частоты запросов_](https://en.wikipedia.org/wiki/Rate_limiting)
// является важным механизмом для контроля использования ресурсов
// и поддержания качества обслуживания. Go элегантно поддерживает
// ограничение частоты запросов с помощью горутин, каналов и тикеров.

package main

import (
	"fmt"
	"time"
)

func main() {

	// Сначала рассмотрим базовое ограничение частоты. Предположим,
	// мы хотим ограничить обработку входящих запросов.
	// Мы будем обрабатывать эти запросы с помощью канала с таким же именем.
	requests := make(chan int, 5)
	for i := 1; i <= 5; i++ {
		requests <- i
	}
	close(requests)

	// Этот канал `limiter` будет получать значение
	// каждые 200 миллисекунд. Это регулятор в нашей схеме
	// ограничения частоты запросов.
	limiter := time.Tick(200 * time.Millisecond)

	// Блокируя получение значения из канала `limiter`
	// перед обработкой каждого запроса, мы ограничиваем
	// себя до 1 запроса каждые 200 миллисекунд.
	for req := range requests {
		<-limiter
		fmt.Println("запрос", req, time.Now())
	}

	// Мы можем захотеть допустить кратковременные всплески запросов
	// в нашей схеме ограничения частоты, сохраняя при этом
	// общий лимит запросов. Мы можем сделать это, добавив буфер
	// в наш канал `limiter`. Этот канал `burstyLimiter` позволит
	// обрабатывать до 3 запросов за один раз.
	burstyLimiter := make(chan time.Time, 3)

	// Заполним канал значениями, чтобы позволить "всплеск" запросов.
	for i := 0; i < 3; i++ {
		burstyLimiter <- time.Now()
	}

	// Каждые 200 миллисекунд мы будем пытаться добавить новое
	// значение в канал `burstyLimiter`, до его предела в 3 значения.
	go func() {
		for t := range time.Tick(200 * time.Millisecond) {
			burstyLimiter <- t
		}
	}()

	// Теперь симулируем еще 5 входящих запросов. Первые
	// 3 из них будут обработаны благодаря возможности "всплеска"
	// канала `burstyLimiter`.
	burstyRequests := make(chan int, 5)
	for i := 1; i <= 5; i++ {
		burstyRequests <- i
	}
	close(burstyRequests)
	for req := range burstyRequests {
		<-burstyLimiter
		fmt.Println("запрос", req, time.Now())
	}
}

// Пояснения:
// Ограничение частоты запросов: В этом примере продемонстрирован механизм ограничения частоты обработки запросов с помощью канала limiter, который получает значения каждые 200 миллисекунд. Это позволяет обрабатывать запросы строго с заданной периодичностью. Это полезно, когда необходимо контролировать количество операций за определенный период времени, например, для API.

// Поддержка всплесков запросов: Чтобы допустить "всплески" в обработке запросов, используется другой канал burstyLimiter, который может содержать до трех значений. Это позволяет обрабатывать до трех запросов подряд без задержки. После исчерпания "запаса" из трех запросов обработка возвращается к обычному ограничению в 200 мс.

// Асинхронная работа с горутинами: Использование горутины для обновления канала burstyLimiter каждые 200 миллисекунд обеспечивает автоматическое поддержание "запаса" для всплесков. Это полезно в ситуациях, когда система может позволить временное увеличение нагрузки, но должна вернуться к стабильному ограничению.

// Такой подход позволяет эффективно контролировать и регулировать нагрузку на систему, избегая перегрузки и поддерживая ее стабильную работу при интенсивной нагрузке.
