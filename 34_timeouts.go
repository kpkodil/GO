// _Тайм-ауты_ важны для программ, которые подключаются к
// внешним ресурсам или которые требуют ограничения
// времени выполнения. Реализация тайм-аутов в Go проста и
// элегантна благодаря каналам и `select`.

package main

import (
	"fmt"
	"time"
)

func main() {

	// В этом примере предположим, что мы выполняем внешний
	// вызов, который возвращает результат через 2 секунды
	// на канале `c1`. Обратите внимание, что канал буферизован,
	// поэтому отправка в горутине неконкурентная (nonblocking).
	// Это обычная практика для предотвращения утечек горутин,
	// если канал никогда не будет прочитан.
	c1 := make(chan string, 1)
	go func() {
		time.Sleep(2 * time.Second)
		c1 <- "result 1"
	}()

	// Вот пример использования `select` с тайм-аутом.
	// `res := <-c1` ожидает результат, а `<-time.After`
	// ожидает значение, которое будет отправлено по истечении
	// тайм-аута в 1 секунду. Поскольку `select` продолжает
	// выполнение с первым готовым каналом, в случае, если
	// операция займет больше разрешенных 1 секунды, будет
	// выбран случай тайм-аута.
	select {
	case res := <-c1:
		fmt.Println(res)
	case <-time.After(1 * time.Second):
		fmt.Println("timeout 1")
	}

	// Если мы установим более длительный тайм-аут в 3 секунды,
	// то получение из `c2` будет успешным, и результат будет напечатан.
	c2 := make(chan string, 1)
	go func() {
		time.Sleep(2 * time.Second)
		c2 <- "result 2"
	}()
	select {
	case res := <-c2:
		fmt.Println(res)
	case <-time.After(3 * time.Second):
		fmt.Println("timeout 2")
	}
}

// Пояснение:
// Тайм-ауты с помощью select:

// В Go можно легко реализовать тайм-ауты с использованием конструкции select. Тайм-ауты помогают избежать блокировки программы при ожидании результата, который может занять слишком много времени.
// Пример с каналом c1:

// Запускается горутина, которая отправляет результат "result 1" в канал c1 после 2 секунд.
// В основном потоке используется select, чтобы одновременно ожидать результат от c1 или тайм-аут от time.After(1 * time.Second). Поскольку операция занимает 2 секунды, больше, чем тайм-аут, будет напечатано "timeout 1".
// Пример с каналом c2:

// Создается второй канал c2, в который горутина отправляет результат "result 2" через 2 секунды.
// В основном потоке используется select, чтобы ожидать либо результат из c2, либо тайм-аут через 3 секунды. Поскольку тайм-аут в 3 секунды больше, чем время ожидания результата, программа успешно получает и печатает "result 2".
