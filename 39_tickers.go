// [Таймеры](timers) предназначены для выполнения действия один раз в будущем,
// тогда как _тикеры_ используются для выполнения действий регулярно с определенным интервалом.
// Вот пример тикера, который периодически срабатывает до тех пор, пока мы не остановим его.

package main

import (
	"fmt"
	"time"
)

func main() {

	// Тикеры используют аналогичный механизм к таймерам: канал, в который отправляются значения.
	// Здесь мы будем использовать встроенный `select` для ожидания значений
	// по мере их поступления каждые 500 мс.
	ticker := time.NewTicker(500 * time.Millisecond)
	done := make(chan bool)

	go func() {
		for {
			select {
			case <-done:
				return
			case t := <-ticker.C:
				fmt.Println("Tick at", t)
			}
		}
	}()

	// Тикеры можно остановить так же, как таймеры. После остановки тикер
	// не будет получать больше значений на своем канале. Мы остановим
	// наш тикер через 1600 мс.
	time.Sleep(1600 * time.Millisecond)
	ticker.Stop()
	done <- true
	fmt.Println("Ticker stopped")
}

// Пояснение:
// Создание тикера:

// time.NewTicker(d) создает тикер, который посылает текущее время в канал ticker.C через регулярные интервалы времени, указанные в d. В этом примере тикер настроен на 500 миллисекунд.
// Работа с тикером:

// В горутине используется цикл for с select для обработки значений, приходящих в канал ticker.C.
// Когда приходит новое значение от тикера, оно выводится на экран с помощью fmt.Println("Tick at", t).
// Если на канал done приходит сигнал (в этом случае, когда он закрывается), цикл завершается, и горутина завершает выполнение.
// Остановка тикера:

// ticker.Stop() останавливает тикер, что предотвращает дальнейшее отправление значений в канал ticker.C.
// После остановки тикера горутина завершается, когда получает сигнал через канал done.
// time.Sleep(1600 * time.Millisecond) заставляет главную функцию ждать достаточно долго (1600 мс), чтобы тикер сработал несколько раз перед остановкой.

// Как это работает:
// Тикеры удобны для выполнения периодических задач, таких как проверка состояния или выполнение регулярных обновлений.
// Остановка тикера предотвращает дальнейшую работу тикера и освобождает ресурсы, связанные с его каналом.
