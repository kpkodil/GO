// Мы часто хотим выполнить код на Go в какой-то момент в будущем
// или периодически через некоторый интервал времени. Встроенные
// функции Go для _таймеров_ и _тикеров_ облегчают обе эти задачи.
// Сначала мы рассмотрим таймеры, а затем [тикеры](tickers).

package main

import (
	"fmt"
	"time"
)

func main() {

	// Таймеры представляют собой одно событие в будущем. Вы
	// указываете таймеру, сколько вы хотите подождать, и он
	// предоставляет канал, который будет уведомлен в это
	// время. Этот таймер будет ждать 2 секунды.
	timer1 := time.NewTimer(2 * time.Second)

	// `<-timer1.C` блокирует выполнение до тех пор, пока
	// таймер не отправит значение в канал `C`, указывая на
	// то, что таймер сработал.
	<-timer1.C
	fmt.Println("Таймер 1 сработал")

	// Если вы просто хотите подождать, вы могли бы использовать
	// `time.Sleep`. Одна из причин, почему таймер может быть
	// полезен, заключается в том, что вы можете отменить
	// таймер до того, как он сработает. Вот пример этого.
	timer2 := time.NewTimer(time.Second)
	go func() {
		<-timer2.C
		fmt.Println("Таймер 2 сработал")
	}()
	stop2 := timer2.Stop()
	if stop2 {
		fmt.Println("Таймер 2 остановлен")
	}

	// Даем `timer2` достаточно времени, чтобы сработать, если
	// он вообще собирался это сделать, чтобы показать, что он
	// действительно остановлен.
	time.Sleep(2 * time.Second)
}

// Пояснение:
// Создание и использование таймера:

// time.NewTimer(d) создает таймер, который будет срабатывать через d продолжительность времени. В этом примере timer1 настроен на 2 секунды.
// <-timer1.C блокирует выполнение до тех пор, пока таймер не сработает и не отправит сигнал в свой канал C. После этого выполняется fmt.Println("Таймер 1 сработал").
// Отмена таймера:

// time.NewTimer(d) также позволяет создать таймер, который можно отменить до его срабатывания. В примере timer2 настроен на 1 секунду.
// В горутине мы пытаемся получить значение из timer2.C, но до этого времени вызываем timer2.Stop(), чтобы отменить таймер.
// stop2 := timer2.Stop() возвращает true, если таймер был успешно остановлен до его срабатывания. В противном случае он возвращает false.
// Если таймер был успешно остановлен, выводится сообщение "Таймер 2 остановлен".
// Проверка остановленного таймера:

// После попытки остановки таймера программа ждет 2 секунды с помощью time.Sleep(2 * time.Second). Это позволяет убедиться, что таймер действительно остановлен, так как timer2 не должен сработать.

// Таймеры полезны, когда нужно выполнить задачу через заданный интервал времени или отменить задачу, если она больше не требуется.
// Отмена таймера позволяет избежать ненужных операций, если задача больше не актуальна до момента срабатывания таймера.
