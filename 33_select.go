// Конструкция _select_ в Go позволяет ожидать несколько операций
// с каналами. Комбинирование горутин и каналов с `select` — мощная
// возможность Go.

package main

import (
	"fmt"
	"time"
)

func main() {

	// В нашем примере мы будем использовать `select` для работы с двумя каналами.
	c1 := make(chan string)
	c2 := make(chan string)

	// Каждому из каналов будет отправлено значение после некоторой задержки.
	// Это имитирует, например, блокирующие RPC-операции, выполняемые
	// в параллельных горутинах.
	go func() {
		time.Sleep(1 * time.Second)
		c1 <- "one" // Отправляем "one" в канал c1 через 1 секунду
	}()
	go func() {
		time.Sleep(2 * time.Second)
		c2 <- "two" // Отправляем "two" в канал c2 через 2 секунды
	}()

	// Используем `select`, чтобы ожидать получения значений из обоих каналов
	// одновременно, выводя каждое значение по мере его поступления.
	for i := 0; i < 2; i++ {
		select {
		case msg1 := <-c1:
			fmt.Println("получено:", msg1) // Когда приходит сообщение из c1
		case msg2 := <-c2:
			fmt.Println("получено:", msg2) // Когда приходит сообщение из c2
		}
	}
}

// Пояснение:
// Горутины: Две отдельные горутины выполняются параллельно:

// Первая ждет 1 секунду и отправляет сообщение "one" в канал c1.
// Вторая ждет 2 секунды и отправляет сообщение "two" в канал c2.
// Конструкция select: В цикле for используется select, чтобы ожидать значения из обоих каналов. select блокирует выполнение программы до тех пор, пока хотя бы одно условие не выполнится:

// Если сообщение поступает из канала c1, оно присваивается переменной msg1, и сообщение выводится на экран.
// Если сообщение поступает из канала c2, оно присваивается переменной msg2, и также выводится на экран.
// Асинхронность и параллелизм: Благодаря использованию горутин и каналов, задержки на 1 и 2 секунды выполняются параллельно, что позволяет программе реагировать на приход сообщений в реальном времени.
