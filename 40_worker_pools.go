// В этом примере мы рассмотрим, как реализовать
// _пул рабочих_ с использованием горутин и каналов.

package main

import (
	"fmt"
	"time"
)

// Вот функция `worker`, которая будет выполнена несколькими
// параллельными экземплярами. Эти рабочие будут получать
// задания на канале `jobs` и отправлять соответствующие
// результаты на канал `results`. Мы используем задержку в
// одну секунду на задание, чтобы смоделировать дорогую задачу.
func worker(id int, jobs <-chan int, results chan<- int) {
	for j := range jobs {
		fmt.Println("worker", id, "started job", j)
		time.Sleep(time.Second)
		fmt.Println("worker", id, "finished job", j)
		results <- j * 2
	}
}

func main() {

	// Для использования нашего пула рабочих нам нужно отправить
	// им задания и собрать их результаты. Мы создаем 2 канала для этого.
	const numJobs = 5
	jobs := make(chan int, numJobs)
	results := make(chan int, numJobs)

	// Запускаем 3 рабочих, которые изначально заблокированы,
	// так как еще нет заданий.
	for w := 1; w <= 3; w++ {
		go worker(w, jobs, results)
	}

	// Отправляем 5 заданий и затем закрываем этот
	// канал, чтобы указать, что это все работы.
	for j := 1; j <= numJobs; j++ {
		jobs <- j
	}
	close(jobs)

	// Наконец, собираем все результаты работы.
	// Это также гарантирует, что горутины-рабочие завершили свою работу.
	// Альтернативный способ ожидания завершения нескольких
	// горутин - использовать [WaitGroup](waitgroups).
	for a := 1; a <= numJobs; a++ {
		fmt.Println(<-results)
	}
}

// Пояснение:
// Функция рабочего:

// Функция worker получает идентификатор рабочего, канал для получения заданий (jobs) и канал для отправки результатов (results).
// Она использует бесконечный цикл for для получения заданий из канала jobs и обработки их.
// В данном примере выполнение задания симулируется с помощью time.Sleep(time.Second), а затем результат (вдвое увеличенное значение задания) отправляется в канал results.
// Создание и запуск рабочих:

// В функции main создаются два канала: jobs для передачи заданий рабочим и results для получения результатов.
// Запускаются три горутины с функцией worker, каждая из которых будет ожидать задания и выполнять их.
// Отправка заданий:

// В цикле for отправляются пять заданий в канал jobs.
// После отправки всех заданий канал jobs закрывается с помощью close(jobs), чтобы указать рабочим, что больше нет заданий.
// Сбор результатов:

// В следующем цикле for программа ожидает получения всех результатов из канала results.
// Каждый результат выводится на экран с помощью fmt.Println(<-results).
