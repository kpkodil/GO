// Основной механизм управления состоянием в Go — это
// взаимодействие через каналы. Мы видели это, например,
// с [пулом воркеров](worker-pools). Однако, существуют и другие
// варианты управления состоянием. Здесь мы рассмотрим
// использование пакета `sync/atomic` для _атомарных счётчиков_,
// к которым могут обращаться несколько горутин.

package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

func main() {

	// Мы будем использовать атомарный целочисленный тип
	// для представления нашего (всегда положительного) счётчика.
	var ops atomic.Uint64

	// WaitGroup поможет нам дождаться завершения работы всех горутин.
	var wg sync.WaitGroup

	// Мы запустим 50 горутин, каждая из которых будет увеличивать
	// счётчик ровно 1000 раз.
	for i := 0; i < 50; i++ {
		wg.Add(1)

		go func() {
			for c := 0; c < 1000; c++ {

				// Для атомарного увеличения счётчика используем `Add`.
				ops.Add(1)
			}

			// Уведомляем WaitGroup о завершении работы горутины.
			wg.Done()
		}()
	}

	// Ожидаем завершения всех горутин.
	wg.Wait()

	// Здесь никакие горутины больше не записывают данные в `ops`, но
	// с помощью метода `Load` мы можем безопасно получить текущее
	// значение атомарно, даже если другие горутины обновляли его.
	fmt.Println("операции:", ops.Load())
}

// Пояснения:
// Атомарные операции: Пакет sync/atomic в Go предоставляет базовые атомарные операции, такие как инкремент, декремент и чтение переменных. Эти операции полезны, когда нужно обновлять значение из разных горутин одновременно без использования сложных механизмов синхронизации, таких как мьютексы. В данном примере используется атомарный тип Uint64 для счётчика, что позволяет безопасно увеличивать значение из нескольких горутин.

// WaitGroup: sync.WaitGroup используется для ожидания завершения всех запущенных горутин. Это упрощает управление параллельными задачами и гарантирует, что программа завершится только после того, как все горутины закончат свою работу.

// Параллельное инкрементирование: В данном примере мы запускаем 50 горутин, каждая из которых 1000 раз увеличивает счётчик. Благодаря атомарным операциям, увеличения происходят безопасно и согласованно, без гонок данных. После завершения всех горутин значение счётчика будет точно равно 50 * 1000 = 50000.

// Атомарное чтение: Метод Load() гарантирует, что считывание значения счётчика происходит атомарно и безопасно даже в условиях параллельного доступа. Это важно, так как счётчик мог бы быть изменён другой горутиной в момент чтения.

// Использование атомарных операций — это удобный способ синхронизации данных между горутинами, когда требуется простое обновление переменных без использования более тяжеловесных конструкций вроде мьютексов.
