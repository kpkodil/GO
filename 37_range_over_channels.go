// В [предыдущем](range-over-built-in-types) примере мы видели, как `for` и
// `range` предоставляют итерацию по базовым структурам данных.
// Мы также можем использовать этот синтаксис для итерации по
// значениям, получаемым из канала.

package main

import "fmt"

func main() {

	// Создаем канал `queue` с буфером на 2 значения.
	queue := make(chan string, 2)
	queue <- "one"
	queue <- "two"
	close(queue) // Закрываем канал после отправки всех значений.

	// Этот `range` итерирует по каждому элементу, когда он
	// получен из канала `queue`. Поскольку канал был закрыт
	// выше, итерация завершается после получения всех 2 элементов.
	for elem := range queue {
		fmt.Println(elem)
	}
}

// Пояснение:
// Создание и заполнение канала:

// Канал queue создается с буфером на 2 значения. Мы отправляем два значения "one" и "two" в канал и затем закрываем его с помощью close(queue). Закрытие канала указывает, что больше не будет новых значений.
// Итерация по каналам с помощью range:

// Цикл for elem := range queue используется для итерации по значениям канала. Когда канал закрыт, range завершает итерацию, после того как все элементы были прочитаны.
// Внутри цикла range каждое значение из канала queue будет присвоено переменной elem, и оно будет напечатано
